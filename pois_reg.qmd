---
title: "pois_reg"
format: html
---

```{r}
library(ggplot2)
```

TO DO: update information, update find_beta, extend sim

The clean versions of the score vector and Fisher information do not exist, as we derive them by component.



U(beta = c(0.5, 0.25, 0.1), 
  Y = "y", 
  X = "x", 
  Z = "z", 
  data = dat)

```{r}
#score function
U <- function(beta, X, Y, Z = NULL, data) {
  
  #turn inputs into matrices
  beta <- matrix(data = beta, ncol = 1)
  data <-  data.matrix(frame = data) #includes X,Z, and potentially other covars
  
  #initialize lambda, score
  l <- exp(beta[1] + data[, c(X, Z)] %*% matrix(beta[-1], ncol = 1)) ## dimension n x 1
  score <- matrix(data = 0, 
                  nrow = nrow(beta)) ## dimension p x 1 (where p = dim(beta))
  
  # save Y - lambda 
  yml = data[, Y] - l ## dimension n x 1
  
  #fill first element of score
  score[1] <- sum(yml)
    
  # save a transformed version of Y - lambda
  ## same column, replicated once for each covariate in (X, Z)
  yml_wide = matrix(data = yml, 
                        nrow = length(yml),
                        ncol = length(c(X, Z)), 
                        byrow = FALSE) ## dimension n x (p - 1)
  
  #fill remaining elements of score
  score[-1] <- colSums(data[, c(X, Z)] * yml_wide)
  
  #return score
  score
}

#Fisher information
info <- function(beta, x, y) {
  
  #initialize matrix, lambda
  I <- matrix(data = c(0,0,0,0), nrow = 2, ncol = 2)
  l <- exp(beta[1] + beta[2]*x)

  
  #fill top left entry in matrix
  I[1,1] <- -1 * sum(l)
  
  #fill mixed entries in matrix
  I[1,2] <- I[2,1] <- -1 * sum(x*l)
  
  #fill in bottom right entry in matrix
  I[2,2] <- -1 * sum(x^2 * l)
  
  #return matrix
  I
}
```

```{r}
find_beta <- function(start_guess, x, y,
                      maxtol = 0.00001,
                      maxiter = 1000,
                      verbose = FALSE) {
  beta_curr <- start_guess
  diff <- maxtol + 1
  iterations <- 0
  while(diff > maxtol & iterations <= maxiter){
    beta_next <- beta_curr - solve(info(beta_curr, x, y)) %*% 
      U(beta = beta_curr, X = "x", Y = "y", Z = NULL, data = data.frame(x, y))#U(beta_curr, x, y)
    diff <- max(abs(beta_next[1] - beta_curr[1]), abs(beta_next[2] - beta_curr[2]))
    iterations <- iterations + 1
    beta_curr <- beta_next
    if(verbose) {
      print(paste("beta_next:", beta_next,"\n"))
      print(paste("diff:", diff, "\n"))
      print(paste("iterations:", iterations, "\n"))
    }
  }
  if(diff > maxtol & iterations >= maxiter){
    conv_msg = "We hit the maximum number of iterations but did not converge."
  }
  else { conv_msg = "We have achieved convergence!"}
  return(list(estimates = beta_curr,
              convergence = conv_msg))
}
```

Now, to test the simple case.
```{r}
set.seed(1031)

beta0 <- 0.5
beta1 <- 0.25
x <- runif(100, min = 0, max = 1) #generate 100 rows from U(0,1)
lambda <- exp(beta0 + beta1*x)
y <- rpois(100, lambda)

my_est <- round(find_beta(c(0,0), x, y)$estimates,2) 

default_est <- round(glm(y ~ x, family = "poisson")$coefficients,2)

```

```{r}
set.seed(1031)
sim <- NULL
simplecase <- TRUE

for(i in 1:1000){
  beta0 <- runif(1, min = 1, max = 2)
  beta1 <- runif(1, min = 2, max = 3)
  beta2 <- runif(1, min = 3, max = 4)
  
  z <- ifelse(simplecase, 
              rep(0, times = 100), #z is zero vector
              rbinom(n = 100, size = 1, prob = 0.3)) #z ~ Bern(0.3)
  x <- runif(100, min = 0, max = 1 + z) #X|Z ~ U(0,1+Z)
  lambda <- exp(beta0 + beta1*x + beta2*z) #mean of Y|X,Z
  y <- rpois(100, lambda) #Y|X,Z ~ Pois(lambda)
  
  mine <- find_beta(c(0,0), x, y)$estimates
  default <- glm(y ~ x, family = "poisson")
  def <- c(default$coefficients[1], default$coefficients[2])
  sim <- cbind(sim, mine - def)
}



#slopes are a little over, intercepts are a little under. interesting
sim |> t() |> data.frame() |> 
  ggplot(aes(x = X1)) + 
  geom_histogram(bins = 100) +
  labs(x = "Diff",
       title = "intercept") 
sim |> t() |> data.frame() |> 
  ggplot(aes(x = X2)) + 
  geom_histogram(bins = 100) +
  labs(x = "Diff", 
       title = "slope")
```

